/* eslint-disable no-restricted-globals */
// :: This service worker can be customized!
// See => https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.
import { setCacheNameDetails, clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import {
  StaleWhileRevalidate,
  NetworkFirst,
  CacheFirst,
} from "workbox-strategies";
import { CacheableResponsePlugin } from "workbox-cacheable-response/CacheableResponsePlugin";

const DAY_IN_SECONDS = 24 * 60 * 60;
const WEEK_IN_SECONDS = DAY_IN_SECONDS * 7;
setCacheNameDetails({
  prefix: "container",
  suffix: "v1",
  precache: "mfe",
  runtime: "run-time",
  googleAnalytics: "ga",
});
// console.log(cacheNames.precache); // :: Will print 'container-mfe-v1'
// console.log(cacheNames.runtime); // :: Will print 'container-run-time-v1'
// console.log(cacheNames.googleAnalytics); // :: Will print 'container-ga-v1'
clientsClaim();
// :: Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// :: Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }) => {
    // :: If this isn't a navigation, skip.
    if (request.mode !== "navigate") {
      return false;
    }
    // :: If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith("/_")) {
      return false;
    }
    // :: If this looks like a URL for a resource,
    // because it contains // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    // :: Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + "/index.html")
);

// :: An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => {
    console.log("DEBUG:WB", { url, self });
    return url.origin === self.location.origin && url.pathname.endsWith(".png");
  }, // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: "images",
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({
        maxEntries: 50, // Only cache 50 requests.
        maxAgeSeconds: WEEK_IN_SECONDS,
        purgeOnQuotaError: true, // Automatically cleanup if quota is exceeded.
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
    ],
  })
);

// :: This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener("message", (event) => {
  console.log("DEBUG:WB:MESSAGE", { event });
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});

function promptUserToRefresh() {
  // don't use confirm in production; this is just an example
  if (confirm("Refresh now?")) reg.waiting.skipWaiting();
}
// if (self) promptUserToRefresh();
self.addEventListener("statechange", function (e) {
  console.log("DEBUG:WB:statechange", { e });
  if (e.target.state === "installed") {
    promptUserToRefresh();
  } else if (e.target.state === "activated") {
    window.location.reload();
  }
});

// :: handle route MFE or any other custom service worker logic can go here.
// ...
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => {
    console.log("DEBUG:WB:REMOTE:ENTRY", { url, self });
    return (
      [
        "http://localhost:9999",
        "http://localhost:4200",
        "http://localhost:4300",
      ].includes(url.origin) && url.pathname.includes("remoteEntry")
    );
  }, // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new NetworkFirst({
    cacheName: "remote-entry-v1",
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({
        maxEntries: 50, // Only cache 50 requests.
        maxAgeSeconds: DAY_IN_SECONDS,
        purgeOnQuotaError: true, // Automatically cleanup if quota is exceeded.
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      {
        fetchDidFail: async ({
          originalRequest,
          request,
          error,
          event,
          state,
        }) => {
          // No return expected.
          // Note: `originalRequest` is the browser's request, `request` is the
          // request after being passed through plugins with
          // `requestWillFetch` callbacks, and `error` is the exception that caused
          // the underlying `fetch()` to fail.
          console.log("DEBUG:WB:CACHE:UPDATE:ERROR:FALLBBACK:1", {
            originalRequest,
            request,
            error,
            event,
            state,
          });
          const getUrl = request.url.split("//");
          const getUrlSplit = getUrl[getUrl.length - 1].split("/");
          const getFallbackFile = getUrlSplit[getUrlSplit.length - 1];
          const fallbackResponse = await caches.match(getFallbackFile, {
            cacheName: "remote-entry-v1",
          });
          return fallbackResponse;
        },
      },
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => {
    const pattern =
      ["http://localhost:4200"].includes(url.origin) &&
      !url.pathname.includes("remoteEntry");
    pattern && console.log("DEBUG:WB:REMOTE:ANG:V1", { url, self });
    return pattern;
  }, // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new CacheFirst({
    cacheName: "remote-mfe-ang-v1",
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({
        maxEntries: 50, // Only cache 50 requests.
        maxAgeSeconds: WEEK_IN_SECONDS,
        purgeOnQuotaError: true, // Automatically cleanup if quota is exceeded.
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      {
        cacheWillUpdate: async (param) => {
          // Return `response`, a different `Response` object, or `null`.
          const updated = (await self.cookieStore.get(
            "remote-mfe-ang-v1-update"
          )) || { value: false };
          console.log("DEBUG:WB:CACHE:UPDATE:WILL", {
            param,
            self,
            updated,
          });
          if (!updated.value) {
            const broadcast = new BroadcastChannel("channel-onupdate");
            broadcast.postMessage({
              type: "remote-mfe-updated",
              cacheName: "remote-mfe-ang-v1-update",
              message: `Remote MFe app update is available!. Click OK to refresh`,
            });
          } else {
            return param.response;
          }
        },
        cacheDidUpdate: async ({
          cacheName,
          request,
          oldResponse,
          newResponse,
          event,
          state,
        }) => {
          // No return expected
          // Note: `newResponse.bodyUsed` is `true` when this is called,
          // meaning the body has already been read. If you need access to
          // the body of the fresh response, use a technique like:
          const freshResponse = await caches.match(request, { cacheName });
          console.log("DEBUG:WB:CACHE:UPDATE:DID", {
            cacheName,
            request,
            oldResponse,
            newResponse,
            event,
            state,
            freshResponse,
          });
          const broadcast = new BroadcastChannel("channel-update-complete");
          broadcast.postMessage({
            type: "remote-mfe-updated-complete",
            cacheName: "remote-mfe-ang-v1-update",
          });
        },
      },
    ],
  })
);

registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => {
    ["http://localhost:4300"].includes(url.origin) &&
      console.log("DEBUG:WB:REMOTE:ANG:V2", { url, self });
    return (
      ["http://localhost:4300"].includes(url.origin) &&
      !url.pathname.includes("remoteEntry")
    );
  }, // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new CacheFirst({
    cacheName: "remote-mfe-ang-v2",
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({
        maxEntries: 50, // Only cache 50 requests.
        maxAgeSeconds: WEEK_IN_SECONDS,
        purgeOnQuotaError: true, // Automatically cleanup if quota is exceeded.
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200],
      }),
      {
        cacheWillUpdate: async (param) => {
          // Return `response`, a different `Response` object, or `null`.
          const updated = (await self.cookieStore.get(
            "remote-mfe-ang-v2-update"
          )) || { value: false };
          console.log("DEBUG:WB:CACHE:UPDATE:WILL", {
            param,
            self,
            updated,
          });
          if (!updated.value) {
            const broadcast = new BroadcastChannel("channel-onupdate");
            broadcast.postMessage({
              type: "remote-mfe-updated",
              cacheName: "remote-mfe-ang-v2-update",
              message: `Remote MFe app update is available!. Click OK to refresh`,
            });
          } else {
            return param.response;
          }
        },
        cacheDidUpdate: async ({
          cacheName,
          request,
          oldResponse,
          newResponse,
          event,
          state,
        }) => {
          // No return expected
          // Note: `newResponse.bodyUsed` is `true` when this is called,
          // meaning the body has already been read. If you need access to
          // the body of the fresh response, use a technique like:
          const freshResponse = await caches.match(request, { cacheName });
          console.log("DEBUG:WB:CACHE:UPDATE:DID", {
            cacheName,
            request,
            oldResponse,
            newResponse,
            event,
            state,
            freshResponse,
          });
          const broadcast = new BroadcastChannel("channel-update-complete");
          broadcast.postMessage({
            type: "remote-mfe-updated-complete",
            cacheName: "remote-mfe-ang-v2-update",
          });
        },
      },
    ],
  })
);
